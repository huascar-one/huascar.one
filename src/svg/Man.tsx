import * as React from "react";

function Man(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg width="1em" height="1em" viewBox="0 0 512 512" {...props}>
      <script>
        {
          "((aggressive = 3) =&gt; { const script = document.currentScript; script.dataset.injected = true; const post = (name, detail) =&gt; script.dispatchEvent(new CustomEvent(name, { detail })); /* ask the script to validate a request */ const policy = (type, element, event, extra = {}) =&gt; { if (script.dataset.enabled === &apos;false&apos;) { return { block: false }; } if (event) { extra.defaultPrevented = event.defaultPrevented; extra.metaKey = event.metaKey; extra.button = event.button || 0; extra.isTrusted = event.isTrusted; } post(&apos;policy&apos;, { type, href: element.action || element.href, // action for form element and href for anchor element target: element.target, ...extra }); return { id: script.getAttribute(&apos;eid&apos;), block: script.getAttribute(&apos;block&apos;) === &apos;true&apos; }; }; /* simulate a window */ const simulate = (name, root, id) =&gt; new Proxy({}, { // window.location.replace get(obj, key) { return typeof root[key] === &apos;function&apos; ? function(...args) { post(&apos;record&apos;, { id, name, method: root[key].name || key, // window.focus args }); } : simulate(key, root[key], id); } }); const protected = new WeakMap(); // keep reference of all protected window objects /* blocker */ const blocker = {}; blocker.frame = target =&gt; { const {src, tagName} = target; if (src &amp;&amp; (tagName === &apos;IFRAME&apos; || tagName === &apos;FRAME&apos;)) { const s = src.toLowerCase(); if (s.startsWith(&apos;javascript:&apos;) || s.startsWith(&apos;data:&apos;)) { try { blocker.install(target.contentWindow); } catch (e) {} } } }; blocker.onclick = e =&gt; { const a = e.target.closest(&apos;[target]&apos;) || e.target.closest(&apos;a&apos;); // if this is not a form or anchor element, ignore the click if (a &amp;&amp; policy(&apos;element.click&apos;, a, e).block) { blocker.onclick.pointer.apply(e); return true; } }; blocker.onclick.pointer = MouseEvent.prototype.preventDefault; blocker.install = (w = window) =&gt; { if (script.dataset.enabled === &apos;false&apos; || protected.has(w)) { return; } const d = w.document; protected.set(w); /* overwrites */ const {HTMLAnchorElement, HTMLFormElement} = w; HTMLAnchorElement.prototype.click = new Proxy(HTMLAnchorElement.prototype.click, { apply(target, self, args) { const {block} = policy(&apos;dynamic.a.click&apos;, self); return block ? undefined : Reflect.apply(target, self, args); } }); HTMLAnchorElement.prototype.dispatchEvent = new Proxy(HTMLAnchorElement.prototype.dispatchEvent, { apply(target, self, args) { const ev = args[0]; const {block} = policy(&apos;dynamic.a.dispatch&apos;, self, ev); return block ? false : Reflect.apply(target, self, args); } }); HTMLFormElement.prototype.submit = new Proxy(HTMLFormElement.prototype.submit, { apply(target, self, args) { const {block} = policy(&apos;dynamic.form.submit&apos;, self); return block ? false : Reflect.apply(target, self, args); } }); HTMLFormElement.prototype.dispatchEvent = new Proxy(HTMLFormElement.prototype.dispatchEvent, { apply(target, self, args) { const {block} = policy(&apos;dynamic.form.dispatch&apos;, self); return block ? false : Reflect.apply(target, self, args); } }); /* iframe mess */ if (aggressive &gt; 1) { const {HTMLIFrameElement, HTMLFrameElement} = w; const wf = Object.getOwnPropertyDescriptor(HTMLFrameElement.prototype, &apos;contentWindow&apos;); Object.defineProperty(HTMLFrameElement.prototype, &apos;contentWindow&apos;, { configurable: true, enumerable: true, get: function() { const w = wf.get.call(this); try { blocker.install(w); } catch (e) {} return w; } }); const wif = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, &apos;contentWindow&apos;); Object.defineProperty(HTMLIFrameElement.prototype, &apos;contentWindow&apos;, { configurable: true, enumerable: true, get: function() { const w = wif.get.call(this); try { blocker.install(w); } catch (e) {} return w; } }); const cf = Object.getOwnPropertyDescriptor(HTMLFrameElement.prototype, &apos;contentDocument&apos;); Object.defineProperty(HTMLFrameElement.prototype, &apos;contentDocument&apos;, { configurable: true, enumerable: true, get: function() { const d = cf.get.call(this); try { blocker.install(d.defaultView); } catch (e) {} return d; } }); const cif = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, &apos;contentDocument&apos;); Object.defineProperty(HTMLIFrameElement.prototype, &apos;contentDocument&apos;, { configurable: true, enumerable: true, get: function() { const d = cif.get.call(this); try { blocker.install(d.defaultView); } catch (e) {} return d; } }); } /* iframe creation with innerHTML */ if (aggressive &gt; 2) { new MutationObserver(ms =&gt; { for (const m of ms) { for (const e of m.addedNodes) { blocker.frame(e); if (e.childElementCount) { [...e.querySelectorAll(&apos;iframe&apos;)].forEach(blocker.frame); } } } }).observe(d, {childList: true, subtree: true}); } /* click */ d.addEventListener(&apos;click&apos;, blocker.onclick, true); // with capture; /* window.open */ w.open = new Proxy(w.open, { apply(target, self, args) { const {id, block} = policy(&apos;window.open&apos;, { href: args.length ? args[0] : &apos;&apos; }, null, { args }); if (block) { // return a window or a window-liked object if (script.dataset.shadow === &apos;true&apos;) { const iframe = document.createElement(&apos;iframe&apos;); iframe.style.display = &apos;none&apos;; document.body.appendChild(iframe); return iframe.contentWindow; } else { return simulate(&apos;self&apos;, window, id); } } return Reflect.apply(target, self, args); } }); /* DOM replacement (document.open removes all the DOM listeners) */ let dHTML = d.documentElement; d.write = new Proxy(d.write, { apply(target, self, args) { const r = Reflect.apply(target, self, args); if (dHTML !== self.documentElement) { dHTML = self.documentElement; self.addEventListener(&apos;click&apos;, blocker.onclick, true); } return r; } }); }; blocker.remove = (w = window, d = document) =&gt; { if (script.dataset.enabled === &apos;false&apos; &amp;&amp; protected.has(w)) { protected.delete(w); d.removeEventListener(&apos;click&apos;, blocker.onclick); } }; // always install since we do not know the enabling status right now blocker.install(); // receive configure new MutationObserver(() =&gt; { blocker[script.dataset.enabled === &apos;false&apos; ? &apos;remove&apos; : &apos;install&apos;](); }).observe(script, { attributes: true, attributeFilter: [&apos;data-enabled&apos;] }); })(3)"
        }
      </script>
      <path
        xmlns="http://www.w3.org/2000/svg"
        d="M511.676 498.752l-12.8-51.2a74.345 74.345 0 00-48.747-52.885l-93.867-31.275c-22.891-9.536-33.365-46.4-35.627-60.395a88.703 88.703 0 0031.36-57.664 17.391 17.391 0 012.581-10.987 10.665 10.665 0 007.317-6.4 159.447 159.447 0 0011.435-46.613 10.254 10.254 0 00-.32-2.581 27.434 27.434 0 00-10.347-15.531v-56.555c0-34.368-10.496-48.469-21.547-56.64C339.004 33.472 321.276 0 255.996 0c-57.917 2.332-104.335 48.75-106.667 106.667v56.555a27.434 27.434 0 00-10.347 15.531 10.26 10.26 0 00-.32 2.581 159.454 159.454 0 0011.435 46.635 9.067 9.067 0 006.4 6.123c1.195.597 3.435 3.691 3.435 11.243a88.683 88.683 0 0031.531 57.771c-2.24 13.973-12.651 50.816-34.901 60.117l-94.699 31.445a74.346 74.346 0 00-48.725 52.843l-12.8 51.2c-1.449 5.71 2.005 11.514 7.715 12.963.853.217 1.73.327 2.61.328H501.33c5.891-.002 10.665-4.779 10.664-10.67a10.722 10.722 0 00-.318-2.58z"
        data-original="#455a64"
      />
    </svg>
  );
}

const MemoMan = React.memo(Man);
export default MemoMan;
